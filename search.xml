<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[智力逻辑摘选（Jrory）]]></title>
    <url>%2F%E6%99%BA%E5%8A%9B%E9%80%BB%E8%BE%91.html</url>
    <content type="text"><![CDATA[问题一 描述: 五个海盗抢到了100颗宝石，每一颗都一样大小和价值连城。他们决定这么分： 抽签决定自己的号码（1、2、3、4、5） 首先，由1号提出分配方案，然后大家表决，当且仅当超过半数的人同意时，按照他的方案进行分配，否则将被扔进大海喂鲨鱼如果1号死后，再由2号提出分配方案，然后剩下的4人进行表决，当且仅当超过半数的人同意时，按照他的方案进行分配，否则将被扔入大海喂鲨鱼，依此类推。条件：每个海盗都是很聪明的人，都能很理智地做出判断，从而做出选择。问题：第一个海盗提出怎样的分配方案才能使自己的收益最大化？ 分析： 假设1、2、3号都死了，只剩4号和5号．这时无论4号怎么分（哪怕分5号100个），5号只要反对，4号就死了（因为没有超过半数同意，非要大于50%才行），4号的生命得不到保障，所以，4号不能让3号死，3号死了4号危险，所以，3号不论怎么分，4号都得同意． 假设1、2号死了，3号来分的话，他肯定分自己100个，4号和5号都0个，因为3号肯定同意，4号也必须同意，就有大于50%的选票．假设1号死了,2号来分．2号肯定不会收买3号，收买4号和5号更好些，因为只要给他们1人1个,4号和5号就都得同意（由假设2，2号死了的话，4号和5号一个也分不到，现在2号给了他们1人1个，他们只得同意，2号会这么分98、0、1、1） 假设1号来分，他不会收买2号，那起码要给2号99个才行，他肯定会收买3号，因为给3号1个，3号就会同意1号的分法，3号要是不同意，1号死了2号分的话，3号一个也得不到，这时1号只要再收买4号和5号中任何一人就行了，给这个人两个，他就必须同意． 所以，1号的分配方案为：97、0、1、2、0 或97、0、1、0、2． 结果： 第一个海盗提出依次是：97，0，1，0，2； 或者是：97，0，1，2，0的分配方案才能够使自己的收益最大化]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>智力</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[The-Art-Of-Programming整理（Jrory）]]></title>
    <url>%2FThe-Art-Of-Programming.html</url>
    <content type="text"><![CDATA[img { border-radius: 15px; } 字符串本章重点介绍6个经典的字符串问题，分别是旋转字符串、字符串包含、字符串转换成整数、回文判断、最长回文子串、字符串的全排列，这6个问题要么从暴力解法入手，然后逐步优化，要么多种思路多种解法。 旋转字符串问题描述： 给定一个字符串，要求把字符串前面的若干个字符移动到字符串的尾部 如实现abcdef-&gt;cdefab的转换。分析过程： 最直接的使用暴力位移法，此处介绍另一种方法－－三次翻转法（时间复杂度O(n)，空间复杂度O(1)） &quot;abcdef&quot;-&gt;&quot;cdefab&quot;: 先翻转ab: abcdef-&gt;bacdef 再翻转cdef: bacdef-&gt;bafedc 最后翻转整个字符串: bafedc-&gt;cdefab 代码示例： 12345678910111213141516void ReverseString(char* s,int from,int to)&#123; while (from &lt; to) &#123; char t = s[from]; s[from++] = s[to]; s[to--] = t; &#125;&#125;void LeftRotateString(char* s,int n,int m)&#123; m %= n; //若要左移动大于n位，那么和%n 是等价的 ReverseString(s, 0, m - 1); //反转[0..m - 1]，套用到上面举的例子中，就是X-&gt;X^T，即 abc-&gt;cba ReverseString(s, m, n - 1); //反转[m..n - 1]，例如Y-&gt;Y^T，即 def-&gt;fed ReverseString(s, 0, n - 1); //反转[0..n - 1]，即如整个反转，(X^TY^T)^T=YX，即 cbafed-&gt;defabc。&#125; 扩展 将一个有序数组循环后移n位后查找某一项（注意理解） 123456789101112131415161718192021222324// 查找某一元素项 // 方法－：运用递归＋二分法查找// 方法二：先找出循环移动的次数n，然后用二分法查找// 此处用方法一int search_item(int * arr , int item,int begin, int end)&#123; if(begin&lt;=end) &#123; int mid = (begin+end)&gt;&gt;1; if(arr[begin] &lt;= arr[mid]) &#123; if(item&gt;=arr[begin] &amp;&amp; item&lt;=arr[mid]) return binary_search(arr, item, begin, mid); else return search_item(arr, item, mid+1, end); &#125; else &#123; if(item&lt;=arr[end] &amp;&amp; item&gt;=arr[mid]) return binary_search(arr, item, mid, end); else return search_item(arr, item, begin, mid-1); &#125; &#125; else return -1;&#125; 字符串包含问题描述： 给定两个分别由字母组成的字符串A和字符串B，字符串B的长度比字符串A短。请问，如何最快地判断字符串B中所有字母是否都在字符串A里 分析过程： 这个问题有多种解法：最直接的排序遍历，此处介绍一种构造hashtable的方法实现 我们可以对字符串A，用位运算（26bit整数表示)计算出一个签名，再用B中的字符到A里面进行查找 代码示例： 1234567891011121314151617181920212223242526272829303132// “最好的方法”，时间复杂度O(n + m)，空间复杂度O(1)bool StringContain(string &amp;a,string &amp;b)&#123; int hash = 0; for (int i = 0; i &lt; a.length(); ++i) &#123; hash |= (1 &lt;&lt; (a[i] - 'A')); &#125; for (int i = 0; i &lt; b.length(); ++i) &#123; if ((hash &amp; (1 &lt;&lt; (b[i] - 'A'))) == 0) &#123; return false; &#125; &#125; return true;&#125;//这个方法的实质是用一个整数代替了hashtable，空间复杂度为O(1)，时间复杂度还是O(n + m)。//// 问题二：变位词(相同字母不同顺序组成的单词)判断// 第一步：给每一个单词加签（选择合适的加签算法，保证变位词的签名一致）// 第二步：将签作为key，单词作为value存放于map中void anagrams(vector&lt;string&gt; &amp;v, map&lt;string, string&gt; &amp;dict)&#123; string temp; for(int i=0; i&lt;v.size(); i++) &#123; temp=v[i]; sort(v[i].begin(), v[i].end()); dict[v[i]] += temp +" "; &#125;&#125; 最长回文字串Manacher算法：O(N)解法分析过程： 首先通过在每个字符的两边都插入一个特殊的符号，将所有可能的奇数或偶数长度的回文子串都转换成了奇数长度。比如 abba 变成 #a#b#b#a#。 此外，为了进一步减少编码的复杂度，可以在字符串的开始加入另一个特殊字符，这样就不用特殊处理越界问题，比如$#a#b#a# 以字符串12212321为例，插入#和$这两个特殊符号，变成了 S[] = &quot;$#1#2#2#1#2#3#2#1#&quot;，然后用一个数组 P[i] 来记录以字符S[i]为中心的最长回文子串向左或向右扩张的长度（包括S[i]）。 比如S和P的对应关系： S # 1 # 2 # 2 # 1 # 2 # 3 # 2 # 1 # P 1 2 1 2 5 2 1 4 1 2 1 6 1 2 1 2 1 可以看出，P[i]-1正好是原字符串中最长回文串的总长度，为5。 接下来怎么计算P[i]呢？Manacher算法增加两个辅助变量id和mx，其中id表示最大回文子串中心的位置，mx则为id+P[id]，也就是最大回文子串的边界。得到一个很重要的结论： 如果mx &gt; i，那么P[i] &gt;= Min(P[2 * id - i], mx - i) 代码解释如下： 123456//mx &gt; i，那么P[i] &gt;= MIN(P[2 * id - i], mx - i)//故谁小取谁if (mx - i &gt; P[2*id - i])P[i] = P[2*id - i];else //mx-i &lt;= P[2*id - i]P[i] = mx - i; 下面，令j = 2*id - i，也就是说j是i关于id的对称点。 当 mx - i &gt; P[j] 的时候，以S[j]为中心的回文子串包含在以S[id]为中心的回文子串中，由于i和j对称，以S[i]为中心的回文子串必然包含在以S[id]为中心的回文子串中，所以必有P[i] = P[j]； 当 P[j] &gt;= mx - i 的时候，以S[j]为中心的回文子串不一定完全包含于以S[id]为中心的回文子串中，但是基于对称性可知，以S[i]为中心的回文子串，其向右至少会扩张到mx的位置，也就是说P[i] &gt;= mx - i。至于mx之后的部分是否对称，再具体匹配。 此外，对于 mx &lt;= i 的情况，因为无法对 P[i]做更多的假设，只能让P[i] = 1，然后再去匹配 综上，关键代码如下： 123456789101112131415//输入，并处理得到字符串sint p[1000], mx = 0, id = 0;memset(p, 0, sizeof(p));for (i = 1; s[i] != '\0'; i++) &#123; p[i] = mx &gt; i ? min(p[2 * id - i], mx - i) : 1; while (s[i + p[i]] == s[i - p[i]]) p[i]++; if (i + p[i] &gt; mx) &#123; mx = i + p[i]; id = i; &#125;&#125;//找出p[i]中最大的 字符串全排列解法分析： 递归实现 取出数组中第一个元素放到最后，即a[1]与a[n]交换，然后递归求a[n-1]的全排列 如果数组只有一个元素n=1，a={1} 则全排列就是{1} 如果数组有两个元素n=2，a={1,2} 则全排列是: {2,1}--a[1]与a[2]交换。交换后求a[2-1]={2}的全排列，归结到1) {1,2}--a[2]与a[2]交换。交换后求a[2-1]={1}的全排列，归结到1) 如果数组有三个元素n=3，a={1,2,3} 则全排列是: a[i]分别与a[len]交换，然后每一步转换成上一步操作 代码示例 1234567891011121314151617181920212223void CalcAllPermutation(char* perm, int from, int to)&#123; if (to &lt;= 1) &#123; return; &#125; if (from == to) &#123; for (int i = 0; i &lt;= to; i++) cout &lt;&lt; perm[i]; cout &lt;&lt; endl; &#125; else &#123; for (int j = from; j &lt;= to; j++) &#123; swap(perm[j], perm[from]); CalcAllPermutation(perm, from + 1, to); swap(perm[j], perm[from]); &#125; &#125;&#125; 字典序排列：利用STL中的next_permutation算法实现 字母组合问题描述： 求出由26个英文字母组成的所有组合 分析过程： 用0和1分别表示对应位字母，组成一张gray表，解析这张表即可得到所有字母的组合 例如abc对应的gray表为:000 001 011 010 110 111 101 100 代码示例： 12345678910111213141516171819typedef vector&lt;string&gt; gray;char a[27] = "abcdefghijklmnopqrstuvwxyz";gray gernalGrayCode(int n)&#123; gray code(pow(2,n)); int len = code.size(); if(n == 1)&#123; code[0] = "0"; code[1] = "1"; return code; &#125; gray g_code = gernalGrayCode(n - 1); for(int i = 0; i &lt; g_code.size(); i++) &#123; code[i] = "0" + g_code[i]; code[len - 1 - i] = "1" + g_code[i]; &#125; return code;&#125; 另一种利用非递归的方式构造格雷码，非常简洁的代码 1234567vector&lt;int&gt; grayCode(int n) &#123; vector&lt;int&gt;res; for(int i=0;i&lt;(1&lt;&lt;n);i++)&#123;//执行2^n次，因为n位格雷码总共有2^n个编码 res.push_back(i^(i&gt;&gt;1));//关键步骤，利用异或运算产生和当前编码有且只有一位不同的格雷码 &#125; return res; &#125; 小结扩展 ① 第一个只出现一次的字符 在一个字符串中找到第一个只出现一次的字符。如输入abaccdeff，则输出b。 ② 对称子字符串的最大长度 输入一个字符串，输出该字符串中对称的子字符串的最大长度。比如输入字符串google，由于该字符串里最长的对称子字符串是goog，因此输出4。提示：可能很多人都写过判断一个字符串是不是对称的函数，这个题目可以看成是该函数的加强版。 ③ 编程判断俩个链表是否相交 给出俩个单向链表的头指针，比如h1，h2，判断这俩个链表是否相交。为了简化问题，我们假设俩个链表均不带环。问题扩展：如果链表可能有环列?如果需要求出俩个链表相交的第一个节点列? ④ 逆序输出链表 输入一个链表的头结点，从尾到头反过来输出每个结点的值。 ⑤ 在O(1)时间内删除单链表结点 给定单链表的一个结点的指针，同时该结点不是尾结点，此外没有指向其它任何结点的指针，请在O(1)时间内删除该结点。 ⑥ 找出链表的第一个公共结点 两个单向链表，找出它们的第一个公共结点。 ⑦ 在字符串中删除特定的字符 输入两个字符串，从第一字符串中删除第二个字符串中所有的字符。例如，输入They are students.和aeiou，则删除之后的第一个字符串变成Thy r stdnts.。 ⑧字符串的匹配 在一篇英文文章中查找指定的人名，人名使用二十六个英文字母（可以是大写或小写）、空格以及两个通配符组成* ?，通配符*表示零个或多个任意字母，通配符?表示一个任意字母。如：J* Smi?? 可以匹配John Smith . ⑨ 字符个数的统计 char *str = &quot;AbcABca&quot; 写出一个函数，查找出每个字符的个数，区分大小写，要求时间复杂度是n（提示用ASCII码） ⑩ 最小子串 给一篇文章，里面是由一个个单词组成，单词中间空格隔开，再给一个字符串指针数组，比如 char *str[]={&quot;hello&quot;,&quot;world&quot;,&quot;good&quot;};求文章中包含这个字符串指针数组的最小子串。注意，只要包含即可，没有顺序要求。提示：文章也可以理解为一个大的字符串数组，单词之前只有空格，没有标点符号。 数组寻找第k小的数问题描述： 输入n个整数，输出其中第k小的 分析过程： 选取S中一个元素作为枢纽元v，将集合S-{v}分割成S1和S2，就像快速排序那样 如果k &lt;= |S1|，那么第k个最小元素必然在S1中。在这种情况下，返回QuickSelect(S1, k)。如果k = 1 + |S1|，那么枢纽元素就是第k个最小元素，即找到，直接返回它。 否则，这第k个最小元素就在S2中，即S2中的第（k - |S1| - 1）个最小元素，我们递归调用并返回QuickSelect(S2, k - |S1| - 1)。代码示例： 此算法的平均运行时间为O(n)。 代码示例： 1234567891011121314151617181920212223242526272829//QuickSelect 将第k小的元素放在 a[k-1] void QuickSelect( int a[], int k, int left, int right )&#123; int i, j; int pivot; if( left + cutoff &lt;= right ) &#123; pivot = median3( a, left, right ); //取三数中值作为枢纽元，可以很大程度上避免最坏情况 i = left; j = right - 1; for( ; ; ) &#123; while( a[ ++i ] &lt; pivot )&#123; &#125; while( a[ --j ] &gt; pivot )&#123; &#125; if( i &lt; j ) swap( &amp;a[ i ], &amp;a[ j ] ); else break; &#125; //重置枢纽元 swap( &amp;a[ i ], &amp;a[ right - 1 ] ); if( k &lt;= i ) QuickSelect( a, k, left, i - 1 ); else if( k &gt; i + 1 ) QuickSelect( a, k, i + 1, right ); &#125; else InsertSort( a + left, right - left + 1 );&#125; 寻找和为定值的多个数问题描述： 输入两个整数n和sum，从数列1，2，3…….n 中随意取几个数，使其和等于sum，要求将其中所有的可能组合列出来。 分析过程： 解法一： 注意到取n，和不取n个区别即可，考虑是否取第n个数的策略，可以转化为一个只和前n-1个数相关的问题。 如果取第n个数，那么问题就转化为“取前n-1个数使得它们的和为sum-n”，对应的代码语句就是sumOfkNumber(sum - n, n - 1)； 如果不取第n个数，那么问题就转化为“取前n-1个数使得他们的和为sum”，对应的代码语句为sumOfkNumber(sum, n - 1)。 参考代码： 1234567891011121314151617181920void SumOfkNumber(int sum, int n)&#123; // 递归出口 if (n &lt;= 0 || sum &lt;= 0) return; // 输出找到的结果 if (sum == n) &#123; // 反转list list1.reverse(); for (list&lt;int&gt;::iterator iter = list1.begin(); iter != list1.end(); iter++) cout &lt;&lt; *iter &lt;&lt; " + "; cout &lt;&lt; n &lt;&lt; endl; list1.reverse()//此处还需反转回来 &#125; list1.push_front(n); //典型的01背包问题 SumOfkNumber(sum - n, n - 1); //“放”n，前n-1个数“填满”sum-n list1.pop_front(); SumOfkNumber(sum, n - 1); //不“放”n，n-1个数“填满”sum&#125; 解法二： 这个问题属于子集和问题（也是背包问题）。本程序采用回溯法+剪枝，其中X数组是解向量，t=∑(1,..,k-1)Wi*Xi, r=∑(k,..,n)Wi，且 若t+Wk+W(k+1)&lt;=M,则Xk=true，递归左儿子(X1,X2,..,X(k-1),1)；否则剪枝； 若t+r-Wk&gt;=M &amp;&amp; t+W(k+1)&lt;=M,则置Xk=0，递归右儿子(X1,X2,..,X(k-1),0)；否则剪枝； 本题中W数组就是(1,2,..,n),所以直接用k代替WK值 参考代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//输入t， r， 尝试Wkvoid SumOfkNumber(int t, int k, int r, int&amp; M, bool&amp; flag, bool* X)&#123; X[k] = true; // 选第k个数 if (t + k == M) // 若找到一个和为M，则设置解向量的标志位，输出解 &#123; flag = true; for (int i = 1; i &lt;= k; ++i) &#123; if (X[i] == 1) &#123; printf("%d ", i); &#125; &#125; printf("\n"); &#125; else &#123; // 若第k+1个数满足条件，则递归左子树 if (t + k + (k + 1) &lt;= M) &#123; SumOfkNumber(t + k, k + 1, r - k, M, flag, X); &#125; // 若不选第k个数，选第k+1个数满足条件，则递归右子树 if ((t + r - k &gt;= M) &amp;&amp; (t + (k + 1) &lt;= M)) &#123; X[k] = false; SumOfkNumber(t, k + 1, r - k, M, flag, X); &#125; &#125;&#125;void search(int&amp; N, int&amp; M)&#123; // 初始化解空间 bool* X = (bool*)malloc(sizeof(bool)* (N + 1)); memset(X, false, sizeof(bool)* (N + 1)); int sum = (N + 1) * N * 0.5f; if (1 &gt; M || sum &lt; M) // 预先排除无解情况 &#123; printf("not found\n"); return; &#125; bool f = false; SumOfkNumber(0, 1, sum, M, f, X); if (!f) &#123; printf("not found\n"); &#125; free(X);&#125; 背包问题扩展 背包问题是最基础的背包问题，其具体描述为：有N件物品和一个容量为V的背包。放入第i件物品耗费的费用是Ci，得到的价值是Wi。求解将哪些物品装入背包可使价值总和最大。 简单分析下：这是最基础的背包问题，特点是每种物品仅有一件，可以选择放或不放。用子问题定义状态：即F[i, v]表示前i件物品恰放入一个容量为v的背包可以获得的最大价值。则其状态转移方程便是： F[i, v] = max{F[i-1, v], F[i-1, v-Ci ] + Wi} 根据前面的分析，我们不难理解这个方程的意义：“将前i件物品放入容量为v的背包中”这个子问题，若只考虑第i件物品的策略（放或不放），那么就可以转化为一个只和前 i-1 件物品相关的问题。即： 如果不放第i件物品，那么问题就转化为“前i-1件物品放入容量为v的背包中”，价值为 F[i-1, v ]； 如果放第i件物品，那么问题就转化为“前i-1件物品放入剩下的容量为v-Ci的背包中”，此时能获得的最大价值就是F[i-1, v-Ci]再加上通过放入第i件物品获得的价值Wi。伪代码如下： 1234F[0,0...V] ← 0for i ← 1 to N for v ← Ci to V F[i, v] ← max&#123;F[i-1, v], F[i-1, v-Ci] + Wi &#125; 这段代码的时间和空间复杂度均为 O(VN)，其中时间复杂度应该已经不能再优化了，但空间复杂度却可以优化到O(V)。感兴趣的读者可以继续思考或者参考网上一个不错的文档《背包问题九讲》。 字数组最大和问题描述： 输入一个整形数组，数组里有正数也有负数。数组中连续的一个或多个整数组成一个子数组，每个子数组都有一个和。 求所有子数组的和的最大值，要求时间复杂度为O(n)。 分析过程： 逗比方法， 三层循环搞定 类背包思路， 事实上，当我们令currSum为当前最大子数组的和，maxSum为最后要返回的最大子数组的和，当我们往后扫描时， 对第j+1个元素有两种选择：要么放入前面找到的子数组，要么做为新子数组的第一个元素； 如果currSum加上当前元素a[j]后不小于a[j]，则令currSum加上a[j]，否则currSum重新赋值，置为下一个元素，即currSum = a[j]。 同时，当currSum &gt; maxSum，则更新maxSum = currSum，否则保持原值，不更新， 即: 12currSum = max(a[j], currSum + a[j]);maxSum = max(maxSum, currSum); 代码示例： 1234567891011int MaxSubArray(int* a, int n)&#123; int currSum = 0; int maxSum = a[0]; //全负情况，返回最大数 for (int j = 0; j &lt; n; j++) &#123; currSum = (a[j] &gt; currSum + a[j]) ? a[j] : currSum + a[j]; maxSum = (maxSum &gt; currSum) ? maxSum : currSum; &#125; return maxSum;&#125; 跳台阶问题(Fibonacci数列)问题描述： 一个台阶总共有n 级，如果一次可以跳1 级，也可以跳2 级。求总共有多少总跳法，并分析算法的时间复杂度。 分析过程： 现在我们再来讨论一般情况。我们把n级台阶时的跳法看成是n的函数，记为f(n)。 当n&gt;2时，第一次跳的时候就有两种不同的选择： 一是第一次只跳1级，此时跳法数目等于后面剩下的n-1级台阶的跳法数目，即为f(n-1)； 另外一种选择是第一次跳2级，此时跳法数目等于后面剩下的n-2级台阶的跳法数目，即为f(n-2)。 因此n级台阶时的不同跳法的总数f(n)=f(n-1)+f(n-2)。 公式总结如下： 123 / 1 n = 1f(n)= 2 n = 2 \ f(n-1) + f(n-2) n &gt; 2 原来上述问题就是我们平常所熟知的Fibonacci数列问,可编写代码，如下: 1234567long long Fibonacci(unsigned int n)&#123; int result[3] = &#123;0, 1, 2&#125;; if (n &lt;= 2) return result[n]; return Fibonacci(n - 1) + Fibonacci(n - 2);&#125; 那么，如果一个人上台阶可以一次上1个，2个，或者3个呢？这个时候，公式是这样写的： 1234 / 1 n = 1f(n)= 2 n = 2 4 n = 3 //111, 12, 21, 3 \ f(n-1)+f(n-2)+f(n-3) n &gt; 3 事实上，我们可以从后往前推，一步步利用之前计算的结果递推 初始化时，dp[0]=dp[1]=1，然后递推计算即可：dp[n] = dp[n-1] + dp[n-2]。 参考代码: 12345678910111213141516//1, 1, 2, 3, 5, 8, 13, 21..int ClimbStairs(int n)&#123; int dp[3] = &#123; 1, 1 &#125;; if (n &lt; 2) &#123; return 1; &#125; for (int i = 2; i &lt;= n; i++) &#123; dp[2] = dp[0] + dp[1]; dp[0] = dp[1]; dp[1] = dp[2]; &#125; return dp[2];&#125; 小结扩展 扩展： 想兑换100元钱，有1,2,5,10四种钱，问总共有多少兑换方法。 递归： 12345678910int coinExchangeRecursion(int n, int m) //递归方式实现，更好理解&#123; if (n == 0) //跳出递归的条件 return 1; if (n &lt; 0 || m == 0) return 0; return (coinExchangeRecursion(n, m-1) + coinExchangeRecursion(n-dimes[m-1], m)); //分为两种情况，如果没有换当前硬币，那么是多少？ //加上，如果换了当前硬币，总值减少，此时又是多少种兑换方法？&#125; 非递归（注意理解） 12345678910111213141516171819const int N = 100; int dimes[] = &#123;1, 2, 5, 10&#125;; int arr[N+1] = &#123;1&#125;;int coinExchange(int n)&#123; int i, j; //每个arr[j]都要有一次是假设兑换了dimes[i]，所以我们要遍历一次 //可以看出arr[j] = arr[j] + arr[j-dimes[i]] //对应着上面的递归方式： //arr[j]:coinExchangeRecursion(n, m-1) //arr[j-dimes[i]]:coinExchangeRecursion(n-dimes[m-1], m) for (i = 0; i &lt; sizeof(dimes)/sizeof(int); i++) &#123; for (j = dimes[i]; j &lt;= n; j++) arr[j] += arr[j-dimes[i]]; &#125; return arr[n];&#125; 此问题还有一个变形，就是打印出路径目前只想到要使用递归来解决这个问题。对此，利用一个vector来保存路径，每进入一层，push_back一个路径，每退出一层，pop_back一个路径。 123456789101112131415161718192021int coinExchangeRecursion(int n, int m) //递归方式实现，更好理解&#123; if (n == 0) //跳出递归的条件 &#123; int i; for (i = 0; i &lt; 4; i++) &#123; int cnt = count(vv.begin(), vv.end(), dimes[i]); cout &lt;&lt; dimes[i] &lt;&lt; ": " &lt;&lt; cnt &lt;&lt;'\t'; &#125; cout &lt;&lt; endl; return 1; &#125; if (n &lt; 0 || m == 0) return 0; vv.push_back(dimes[m-1]); int yes = coinExchangeRecursion(n-dimes[m-1], m); vv.pop_back(); int no = coinExchangeRecursion(n, m-1); return (no+yes);&#125; 奇偶调序问题描述： 输入一个整数数组，调整数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。要求时间复杂度为O(n)。 分析过程： 借助快速排序思想， 区别是快速排序是比较大下， 次数是判断奇偶 代码参考： 123456789101112131415161718192021222324252627282930bool IsOddNumber(int data)&#123; return (data&amp;1) == 1;&#125;//奇偶互换void OddEvenSort(int *pData, unsigned int length)&#123; if(pData == NULL || length &lt;0) &#123; return; &#125; int * pbegin= pData; int * pend = pData+length-1; while (pbegin - pend &lt; 0) &#123; if(IsOddNumber(*pbegin)) &#123; pbegin++; &#125; if(!IsOddNumber(*pend)) &#123; pend--; &#125; else &#123; swap(*pbegin, *pend); &#125; &#125;&#125; 变形： 分类： 现有n个红白蓝三种不同颜色的小球，乱序排列在一起，请通过两两交换任意两个球，使得从左至右，依次是一些红球、一些白球、一些蓝球。 简析： 通过前面的分析得知，这个问题类似快排中partition过程，只是需要用到三个指针：一个前指针begin，一个中指针current，一个后指针end，current指针遍历整个数组序列，当 current指针所指元素为0时，与begin指针所指的元素交换，而后current++，begin++ ； current指针所指元素为1时，不做任何交换（即球不动），而后current++ ； current指针所指元素为2时，与end指针所指的元素交换，而后，current指针不动，end– 。 注意第三步中current不能动， 因为有可能与end交换后变成0， 回到第一步与begin再交换代码如下：123456789101112131415161718192021222324void Holland(int* data, int len)&#123; int* begin = data; int* current = data; int* end = data+len-1; while (current&lt;=end) &#123; if(*current == 1) &#123; current++; &#125; else if(*current == 0) &#123; swap(*begin, *current); current++; begin++; &#125; else &#123; swap(*end, *current); end--; &#125; &#125;&#125; 完美洗牌算法简述题目描述： 有个长度为2n的数组{a1,a2,a3,…,an,b1,b2,b3,…,bn}，希望排序后{a1,b1,a2,b2,….,an,bn}，请考虑有无时间复杂度o(n)，空间复杂度0(1)的解法。 分析过程： 方法一：蛮力变换：遍历移位，效率很low 下面着重介绍完美洗牌算法： 如果一副牌用a1 a2 a3 a4 b1 b2 b3 b4表示（为简化问题，假设这副牌只有8张牌），然后一分为二之后，左手上的牌可能是a1 a2 a3 a4，右手上的牌是b1 b2 b3 b4，那么在如上图那样的洗牌之后，得到的牌就可能是b1 a1 b2 a2 b3 a3 b4 a4。 起始序列：a1 a2 a3 a4 b1 b2 b3 b4 数组下标：1 2 3 4 5 6 7 8 最终序列：b1 a1 b2 a2 b3 a3 b4 a4,下图表示出每张牌的位置变化： 位置置换pefect_shuffle1算法 由图可知： 前n个元素中，第i个元素去了 第（2 * i）的位置。 后n个元素，第i个元素去了第 (2 * (i - n) ) - 1 = 2 * i - (2 * n + 1) = (2 * i) % (2 * n + 1)个位置。 任意的第i个元素，我们最终换到了 (2 * i) % (2 * n + 1)的位置 当0 &lt; i &lt; n时， 原式= (2i) % (2 * n + 1) = 2i； 当i &gt; n时，原式(2 * i) % (2 * n + 1)保持不变。 因此，也就产生了最简单的方法pefect_shuffle1，参考代码如下： 12345678910111213// 时间O(n)，空间O(n) 数组下标从1开始void PefectShuffle1(int *a, int n)&#123; int n2 = n * 2, i, b[N]; for (i = 1; i &lt;= n2; ++i) &#123; b[(i * 2) % (n2 + 1)] = a[i]; &#125; for (i = 1; i &lt;= n2; ++i) &#123; a[i] = b[i]; &#125;&#125; 完美洗牌算法perfect_shuffle2 走圈算法cycle_leader 当n=4的情况：起始序列：a1 a2 a3 a4 b1 b2 b3 b4数组下标：1 2 3 4 5 6 7 8 最终序列：b1 a1 b2 a2 b3 a3 b4 a4 即通过置换，我们可以看出有两个圈(如上图)，一个是1 -&gt; 2 -&gt; 4 -&gt; 8 -&gt; 7 -&gt; 5 -&gt; 1；一个是3 -&gt; 6 -&gt; 3。 这两个圈可以表示为（1,2,4,8,7,5）和（3,6），且perfect_shuffle1算法也已经告诉了我们，不管你n是奇数还是偶数，每个位置的元素都将变为第（2*i） % （2n+1）个元素： 因此我们只要知道圈里最小位置编号的元素即圈的头部，顺着圈走一遍就可以达到目的，且因为圈与圈是不相交的，所以这样下来，我们刚好走了O（N）步。 还是举n=4的例子，且假定我们已经知道第一个圈和第二个圈的前提下，要让1 2 3 4 5 6 7 8变换成5 1 6 2 7 3 8 4：第一个圈：1 -&gt; 2 -&gt; 4 -&gt; 8 -&gt; 7 -&gt; 5 -&gt; 1第二个圈：3 -&gt; 6 -&gt; 3： 原始数组：1 2 3 4 5 6 7 8数组下标：1 2 3 4 5 6 7 8走第一圈：5 1 3 2 7 6 8 4 走第二圈：5 1 6 2 7 3 8 4上面沿着圈走的算法我们给它取名为cycle_leader，这部分代码如下： 12345678910111213//数组下标从1开始，from是圈的头部，mod是要取模的数 //mod 应该为 2 * n + 1，时间复杂度O(圈长）void CycleLeader(int *a, int from, int mod)&#123; int t,i; for (i = from * 2 % mod; i != from; i = i * 2 % mod) &#123; t = a[i]; a[i] = a[from]; a[from] = t; &#125;&#125; 神级结论：对于2*n=(3^k-1）这种长度的数组,恰好只有k个圈，且每个圈头部的起始位置分别是1,3,9，...3^(k-1)。 若给定的长度n,可以采取分而治之算法的思想，把整个数组一分为二，即拆分成两个部分：让一部分的长度满足神级结论：若2*m =(3^k-1)则恰好k个圈，且每个圈头部的起始位置分别是1,3,9，...3^(k-1)。其中m &lt; n，m往神级结论所需的值上套；剩下的n-m部分单独计算 当把n分解成m和n-m两部分后，原始数组对应的下标如下（为了方便描述，我们依然只需要看数组下标就够了）： 原始数组下标：1..m m+1.. n， n+1 .. n+m, n+m+1,..2*n 且为了能让前部分的序列满足神级结论2*m=(3^k-1)，我们可以把中间那两段长度为n-m和m的段交换位置，即相当于把m+1..n，n+1..n+m的段循环右移m次（为什么要这么做？因为如此操作后，数组的前部分的长度为2m，而根据神级结论：当2m=3^k-1时，可知这长度2m的部分恰好有k个圈）。 举个实例说明：当给定n=7时，若要满足神级结论2*n=3^k-1，k只能取2，继而推得n&#39;=m=4。原始数组：a1 a2 a3 a4 a5 a6 a7 b1 b2 b3 b4 b5 b6 b7既然m=4，即让上述数组中有下划线的两个部分交换，得到：目标数组：a1 a2 a3 a4 b1 b2 b3 b4 a5 a6 a7 b5 继而目标数组中的前半部分a1 a2 a3 a4 b1 b2 b3 b4部分可以用走圈算法cycle_leader搞定，于此我们最终求解的n长度变成了n’=3，即n的长度减小了4，单独再解决后半部分a5 a6 a7 b5 b6 b7即可。 完美洗牌算法perfect_shuffle3 从上文的分析过程中也就得出了我们的完美洗牌算法，其算法流程为：输入数组 A[1..2 * n] step 1: 找到 2 m = 3^k - 1 使得 3^k &lt;= 2 n &lt; 3^(k +1) step 2: 把a[m + 1..n + m]那部分循环移m位 step 3: 对每个i = 0,1,2..k - 1，3^i是个圈的头部，做cycle_leader算法，数组长度为m，所以对2 * m + 1取模。 step 4: 对数组的后面部分A[2 m + 1.. 2 n]继续使用本算法, 这相当于n减小了m 此完美洗牌算法实现的参考代码如下： 123456789101112131415161718192021222324252627282930void PerfectShuffle2(int *a, int n)&#123; int n2, m, i, k, t; for (; n &gt; 1;) &#123; // step 1 n2 = n * 2; for (k = 0, m = 1; n2 / m &gt;= 3; ++k, m *= 3) ; m /= 2; // 2m = 3^k - 1 , 3^k &lt;= 2n &lt; 3^(k + 1) // step 2 right_rotate(a + m, m, n); // step 3 for (i = 0, t = 1; i &lt; k; ++i, t *= 3) &#123; cycle_leader(a , t, m * 2 + 1); &#125; //step 4 a += m * 2; n -= m; &#125; // n = 1 t = a[1]; a[1] = a[2]; a[2] = t;&#125; 完整代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172//动态规划#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;//翻转字符串时间复杂度O(to - from)void reverse(int *a, int from, int to)&#123; for (; from &lt; to; ++from, --to) &#123; a[from] ^= a[to]; a[to] ^= a[from]; a[from] ^= a[to]; &#125;&#125;//循环右移num位 时间复杂度O(n)void RightRotate(int *a, int num, int n)&#123; reverse(a, 0, n - num - 1); reverse(a, n - num, n-1); reverse(a, 0, n-1);&#125;//数组下标从1开始，from是圈的头部，mod为 2 * n + 1void CycleLeader(int *a, int from, int mod)&#123; for (int i = from * 2 % mod; i != from; i = i * 2 % mod) &#123; a[i-1] ^= a[from-1]; a[from-1] ^= a[i-1]; a[i-1] ^= a[from-1]; &#125;&#125;//时间O(n)，空间O(1)void PerfectShuffle(int *a, int n /*n=N/2*/)&#123; RightRotate(a, n, 2*n);//准备工作 int m, k; for (; n &gt; 1; a += m * 2, n -= m/*step 4*/) &#123; // step 1: 计算k和m的值(2m=3^k-1) for (k = 0, m = 1; (2*n + 1) / m &gt;= 3; ++k, m *= 3); m /= 2; //step 2: 循环右移m位 RightRotate(a + m, m, n); // step 3：按圈交换 for ( int i = 0, t = 1; i &lt; k; ++i, t *= 3) &#123; CycleLeader(a , t, m * 2 + 1); &#125; &#125; a[0] ^= a[1]; a[1] ^= a[0]; a[0] ^= a[1];&#125;int main(int argc, char const *argv[])&#123; int a[10]=&#123;1,2,3,4,5,6,7,8,9,10&#125;; PerfectShuffle(a, 5); for(int i = 0; i&lt; 10; i++) &#123; cout&lt;&lt; a[i]&lt;&lt;","; &#125; cout&lt;&lt;endl; return 0;&#125;]]></content>
      <categories>
        <category>The-Art-Of-Programming</category>
      </categories>
      <tags>
        <tag>The-Art-Of-Programming</tag>
      </tags>
  </entry>
</search>
