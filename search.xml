<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Markdown 概述（Jrory）]]></title>
    <url>%2Ftext.html</url>
    <content type="text"><![CDATA[欢迎使用 Cmd Markdown 编辑阅读器 我们理解您需要更便捷更高效的工具记录思想，整理笔记、知识，并将其中承载的价值传播给他人，Cmd Markdown 是我们给出的答案 —— 我们为记录思想和分享知识提供更专业的工具。 您可以使用 Cmd Markdown： 整理知识，学习笔记 发布日记，杂文，所见所想 撰写发布技术文稿（代码支持） 撰写发布学术论文（LaTeX 公式支持） 除了您现在看到的这个 Cmd Markdown 在线版本，您还可以前往以下网址下载： Windows/Mac/Linux 全平台客户端 请保留此份 Cmd Markdown 的欢迎稿兼使用说明，如需撰写新稿件，点击顶部工具栏右侧的 新文稿 或者使用快捷键 Ctrl+Alt+N。 什么是 MarkdownMarkdown 是一种方便记忆、书写的纯文本标记语言，用户可以使用这些标记符号以最小的输入代价生成极富表现力的文档：譬如您正在阅读的这份文档。它使用简单的符号标记不同的标题，分割不同的段落，粗体 或者 斜体 某些文字，更棒的是，它还可以 1. 制作一份待办事宜 Todo 列表 支持以 PDF 格式导出文稿 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率 新增 Todo 列表功能 修复 LaTex 公式渲染问题 新增 LaTex 公式编号功能 3. 高亮一段代码1234567@requires_authorizationclass SomeClass: passif __name__ == '__main__': # A comment print 'hello world' 4. 高效绘制 流程图12345678st=&gt;start: Startop=&gt;operation: Your Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op 5. 高效绘制 序列图123Alice-&gt;Bob: Hello Bob, how are you?Note right of Bob: Bob thinksBob--&gt;Alice: I am good thanks! 6. 高效绘制 甘特图12345678910111213title 项目开发流程section 项目确定 需求分析 :a1, 2016-06-22, 3d 可行性报告 :after a1, 5d 概念验证 : 5dsection 项目实施 概要设计 :2016-07-05 , 5d 详细设计 :2016-07-08, 10d 编码 :2016-07-15, 10d 测试 :2016-07-22, 5dsection 发布验收 发布: 2d 验收: 3d 7. 绘制表格 项目 价格 数量 计算机 \$1600 5 手机 \$12 12 管线 \$1 234 8. 更详细语法说明想要查看更详细的语法说明，可以参考我们准备的 Cmd Markdown 简明语法手册，进阶用户可以参考 Cmd Markdown 高阶语法手册 了解更多高级功能。 总而言之，不同于其它 所见即所得 的编辑器：你只需使用键盘专注于书写文本内容，就可以生成印刷级的排版格式，省却在键盘和工具栏之间来回切换，调整内容和格式的麻烦。Markdown 在流畅的书写和印刷级的阅读体验之间找到了平衡。 目前它已经成为世界上最大的技术分享网站 GitHub 和 技术问答网站 StackOverFlow 的御用书写格式。 什么是 Cmd Markdown您可以使用很多工具书写 Markdown，但是 Cmd Markdown 是这个星球上我们已知的、最好的 Markdown 工具——没有之一 ：）因为深信文字的力量，所以我们和你一样，对流畅书写，分享思想和知识，以及阅读体验有极致的追求，我们把对于这些诉求的回应整合在 Cmd Markdown，并且一次，两次，三次，乃至无数次地提升这个工具的体验，最终将它演化成一个 编辑/发布/阅读 Markdown 的在线平台——您可以在任何地方，任何系统/设备上管理这里的文字。 1. 实时同步预览我们将 Cmd Markdown 的主界面一分为二，左边为编辑区，右边为预览区，在编辑区的操作会实时地渲染到预览区方便查看最终的版面效果，并且如果你在其中一个区拖动滚动条，我们有一个巧妙的算法把另一个区的滚动条同步到等价的位置，超酷！ 2. 编辑工具栏也许您还是一个 Markdown 语法的新手，在您完全熟悉它之前，我们在 编辑区 的顶部放置了一个如下图所示的工具栏，您可以使用鼠标在工具栏上调整格式，不过我们仍旧鼓励你使用键盘标记格式，提高书写的流畅度。 3. 编辑模式完全心无旁骛的方式编辑文字：点击 编辑工具栏 最右侧的拉伸按钮或者按下 Ctrl + M，将 Cmd Markdown 切换到独立的编辑模式，这是一个极度简洁的写作环境，所有可能会引起分心的元素都已经被挪除，超清爽！ 4. 实时的云端文稿为了保障数据安全，Cmd Markdown 会将您每一次击键的内容保存至云端，同时在 编辑工具栏 的最右侧提示 已保存 的字样。无需担心浏览器崩溃，机器掉电或者地震，海啸——在编辑的过程中随时关闭浏览器或者机器，下一次回到 Cmd Markdown 的时候继续写作。 5. 离线模式在网络环境不稳定的情况下记录文字一样很安全！在您写作的时候，如果电脑突然失去网络连接，Cmd Markdown 会智能切换至离线模式，将您后续键入的文字保存在本地，直到网络恢复再将他们传送至云端，即使在网络恢复前关闭浏览器或者电脑，一样没有问题，等到下次开启 Cmd Markdown 的时候，她会提醒您将离线保存的文字传送至云端。简而言之，我们尽最大的努力保障您文字的安全。 6. 管理工具栏为了便于管理您的文稿，在 预览区 的顶部放置了如下所示的 管理工具栏： 通过管理工具栏可以： 发布：将当前的文稿生成固定链接，在网络上发布，分享 新建：开始撰写一篇新的文稿 删除：删除当前的文稿 导出：将当前的文稿转化为 Markdown 文本或者 Html 格式，并导出到本地 列表：所有新增和过往的文稿都可以在这里查看、操作 模式：切换 普通/Vim/Emacs 编辑模式 7. 阅读工具栏 通过 预览区 右上角的 阅读工具栏，可以查看当前文稿的目录并增强阅读体验。 工具栏上的五个图标依次为： 目录：快速导航当前文稿的目录结构以跳转到感兴趣的段落 视图：互换左边编辑区和右边预览区的位置 主题：内置了黑白两种模式的主题，试试 黑色主题，超炫！ 阅读：心无旁骛的阅读模式提供超一流的阅读体验 全屏：简洁，简洁，再简洁，一个完全沉浸式的写作和阅读环境 8. 阅读模式在 阅读工具栏 点击 或者按下 Ctrl+Alt+M 随即进入独立的阅读模式界面，我们在版面渲染上的每一个细节：字体，字号，行间距，前背景色都倾注了大量的时间，努力提升阅读的体验和品质。 9. 标签、分类和搜索在编辑区任意行首位置输入以下格式的文字可以标签当前文档： 标签： 未分类 标签以后的文稿在【文件列表】（Ctrl+Alt+F）里会按照标签分类，用户可以同时使用键盘或者鼠标浏览查看，或者在【文件列表】的搜索文本框内搜索标题关键字过滤文稿，如下图所示： 10. 文稿发布和分享在您使用 Cmd Markdown 记录，创作，整理，阅读文稿的同时，我们不仅希望它是一个有力的工具，更希望您的思想和知识通过这个平台，连同优质的阅读体验，将他们分享给有相同志趣的人，进而鼓励更多的人来到这里记录分享他们的思想和知识，尝试点击 (Ctrl+Alt+P) 发布这份文档给好友吧！ 再一次感谢您花费时间阅读这份欢迎稿，点击 (Ctrl+Alt+N) 开始撰写新的文稿吧！祝您在这里记录、阅读、分享愉快！ 作者 @Jrory2016 年 07月 07日]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[智力逻辑摘选（Jrory）]]></title>
    <url>%2F%E6%99%BA%E5%8A%9B%E9%80%BB%E8%BE%91.html</url>
    <content type="text"><![CDATA[问题一 五个海盗抢到了100颗宝石，每一颗都一样大小和价值连城。他们决定这么分： 抽签决定自己的号码（1、2、3、4、5） 首先，由1号提出分配方案，然后大家表决，当且仅当超过半数的人同意时，按照他的方案进行分配，否则将被扔进大海喂鲨鱼如果1号死后，再由2号提出分配方案，然后剩下的4人进行表决，当且仅当超过半数的人同意时，按照他的方案进行分配，否则将被扔入大海喂鲨鱼，依此类推。条件：每个海盗都是很聪明的人，都能很理智地做出判断，从而做出选择。问题：第一个海盗提出怎样的分配方案才能使自己的收益最大化？ 123456分析方案:假设1、2、3号都死了，只剩4号和5号．这时无论4号怎么分（哪怕分5号100个），5号只要反对，4号就死了（因为没有超过半数同意，非要大于50%才行），4号的生命得不到保障，所以，4号不能让3号死，3号死了4号危险，所以，3号不论怎么分，4号都得同意．假设1、2号死了，3号来分的话，他肯定分自己100个，4号和5号都0个，因为3号肯定同意，4号也必须同意，就有大于50%的选票．假设1号死了,2号来分．2号肯定不会收买3号，收买4号和5号更好些，因为只要给他们1人1个,4号和5号就都得同意（由假设2，2号死了的话，4号和5号一个也分不到，现在2号给了他们1人1个，他们只得同意，2号会这么分98、0、1、1）假设1号来分，他不会收买2号，那起码要给2号99个才行，他肯定会收买3号，因为给3号1个，3号就会同意1号的分法，3号要是不同意，1号死了2号分的话，3号一个也得不到，这时1号只要再收买4号和5号中任何一人就行了，给这个人两个，他就必须同意．所以，1号的分配方案为：97、0、1、2、0 或97、0、1、0、2．结果：第一个海盗提出依次是：97，0，1，0，2； 或者是：97，0，1，2，0的分配方案才能够使自己的收益最大化]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>智力</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[The-Art-Of-Programming整理（Jrory）]]></title>
    <url>%2FThe-Art-Of-Programming.html</url>
    <content type="text"><![CDATA[img { border-radius: 15px; } 字符串本章重点介绍6个经典的字符串问题，分别是旋转字符串、字符串包含、字符串转换成整数、回文判断、最长回文子串、字符串的全排列，这6个问题要么从暴力解法入手，然后逐步优化，要么多种思路多种解法。 旋转字符串问题描述： 给定一个字符串，要求把字符串前面的若干个字符移动到字符串的尾部 如实现abcdef-&gt;cdefab的转换。分析过程： 最直接的使用暴力位移法，此处介绍另一种方法－－三次翻转法（时间复杂度O(n)，空间复杂度O(1)） “abcdef”-&gt;”cdefab”: 先翻转ab: abcdef-&gt;bacdef 再翻转cdef: bacdef-&gt;bafedc 最后翻转整个字符串: bafedc-&gt;cdefab 代码示例： 12345678910111213141516void ReverseString(char* s,int from,int to)&#123; while (from &lt; to) &#123; char t = s[from]; s[from++] = s[to]; s[to--] = t; &#125;&#125;void LeftRotateString(char* s,int n,int m)&#123; m %= n; //若要左移动大于n位，那么和%n 是等价的 ReverseString(s, 0, m - 1); //反转[0..m - 1]，套用到上面举的例子中，就是X-&gt;X^T，即 abc-&gt;cba ReverseString(s, m, n - 1); //反转[m..n - 1]，例如Y-&gt;Y^T，即 def-&gt;fed ReverseString(s, 0, n - 1); //反转[0..n - 1]，即如整个反转，(X^TY^T)^T=YX，即 cbafed-&gt;defabc。&#125; 扩展 将一个有序数组循环后移n位后查找某一项（注意理解） 123456789101112131415161718192021222324// 查找某一元素项 // 方法－：运用递归＋二分法查找// 方法二：先找出循环移动的次数n，然后用二分法查找// 此处用方法一int search_item(int * arr , int item,int begin, int end)&#123; if(begin&lt;=end) &#123; int mid = (begin+end)&gt;&gt;1; if(arr[begin] &lt;= arr[mid]) &#123; if(item&gt;=arr[begin] &amp;&amp; item&lt;=arr[mid]) return binary_search(arr, item, begin, mid); else return search_item(arr, item, mid+1, end); &#125; else &#123; if(item&lt;=arr[end] &amp;&amp; item&gt;=arr[mid]) return binary_search(arr, item, mid, end); else return search_item(arr, item, begin, mid-1); &#125; &#125; else return -1;&#125; 字符串包含问题描述： 给定两个分别由字母组成的字符串A和字符串B，字符串B的长度比字符串A短。请问，如何最快地判断字符串B中所有字母是否都在字符串A里 分析过程： 这个问题有多种解法：最直接的排序遍历，此处介绍一种构造hashtable的方法实现 我们可以对字符串A，用位运算（26bit整数表示)计算出一个签名，再用B中的字符到A里面进行查找 代码示例： 1234567891011121314151617181920212223242526272829303132// “最好的方法”，时间复杂度O(n + m)，空间复杂度O(1)bool StringContain(string &amp;a,string &amp;b)&#123; int hash = 0; for (int i = 0; i &lt; a.length(); ++i) &#123; hash |= (1 &lt;&lt; (a[i] - 'A')); &#125; for (int i = 0; i &lt; b.length(); ++i) &#123; if ((hash &amp; (1 &lt;&lt; (b[i] - 'A'))) == 0) &#123; return false; &#125; &#125; return true;&#125;//这个方法的实质是用一个整数代替了hashtable，空间复杂度为O(1)，时间复杂度还是O(n + m)。//// 问题二：变位词(相同字母不同顺序组成的单词)判断// 第一步：给每一个单词加签（选择合适的加签算法，保证变位词的签名一致）// 第二步：将签作为key，单词作为value存放于map中void anagrams(vector&lt;string&gt; &amp;v, map&lt;string, string&gt; &amp;dict)&#123; string temp; for(int i=0; i&lt;v.size(); i++) &#123; temp=v[i]; sort(v[i].begin(), v[i].end()); dict[v[i]] += temp +" "; &#125;&#125; 最长回文字串Manacher算法：O(N)解法分析过程： 首先通过在每个字符的两边都插入一个特殊的符号，将所有可能的奇数或偶数长度的回文子串都转换成了奇数长度。比如 abba 变成 #a#b#b#a#。 此外，为了进一步减少编码的复杂度，可以在字符串的开始加入另一个特殊字符，这样就不用特殊处理越界问题，比如$#a#b#a# 以字符串12212321为例，插入#和$这两个特殊符号，变成了 S[] = &quot;$#1#2#2#1#2#3#2#1#&quot;，然后用一个数组 P[i] 来记录以字符S[i]为中心的最长回文子串向左或向右扩张的长度（包括S[i]）。 比如S和P的对应关系： S # 1 # 2 # 2 # 1 # 2 # 3 # 2 # 1 # P 1 2 1 2 5 2 1 4 1 2 1 6 1 2 1 2 1 可以看出，P[i]-1正好是原字符串中最长回文串的总长度，为5。 接下来怎么计算P[i]呢？Manacher算法增加两个辅助变量id和mx，其中id表示最大回文子串中心的位置，mx则为id+P[id]，也就是最大回文子串的边界。得到一个很重要的结论： 如果mx &gt; i，那么P[i] &gt;= Min(P[2 * id - i], mx - i) 代码解释如下： 123456//mx &gt; i，那么P[i] &gt;= MIN(P[2 * id - i], mx - i)//故谁小取谁if (mx - i &gt; P[2*id - i]) P[i] = P[2*id - i];else //mx-i &lt;= P[2*id - i] P[i] = mx - i; 下面，令j = 2*id - i，也就是说j是i关于id的对称点。 当 mx - i &gt; P[j] 的时候，以S[j]为中心的回文子串包含在以S[id]为中心的回文子串中，由于i和j对称，以S[i]为中心的回文子串必然包含在以S[id]为中心的回文子串中，所以必有P[i] = P[j]； 当 P[j] &gt;= mx - i 的时候，以S[j]为中心的回文子串不一定完全包含于以S[id]为中心的回文子串中，但是基于对称性可知，以S[i]为中心的回文子串，其向右至少会扩张到mx的位置，也就是说P[i] &gt;= mx - i。至于mx之后的部分是否对称，再具体匹配。 此外，对于 mx &lt;= i 的情况，因为无法对 P[i]做更多的假设，只能让P[i] = 1，然后再去匹配 综上，关键代码如下： 123456789101112131415//输入，并处理得到字符串sint p[1000], mx = 0, id = 0;memset(p, 0, sizeof(p));for (i = 1; s[i] != '\0'; i++) &#123; p[i] = mx &gt; i ? min(p[2 * id - i], mx - i) : 1; while (s[i + p[i]] == s[i - p[i]]) p[i]++; if (i + p[i] &gt; mx) &#123; mx = i + p[i]; id = i; &#125;&#125;//找出p[i]中最大的 字符串全排列解法分析： 递归实现 取出数组中第一个元素放到最后，即a[1]与a[n]交换，然后递归求a[n-1]的全排列 如果数组只有一个元素n=1，a={1} 则全排列就是{1} 如果数组有两个元素n=2，a={1,2} 则全排列是: {2,1}--a[1]与a[2]交换。交换后求a[2-1]={2}的全排列，归结到1) {1,2}--a[2]与a[2]交换。交换后求a[2-1]={1}的全排列，归结到1) 如果数组有三个元素n=3，a={1,2,3} 则全排列是: a[i]分别与a[len]交换，然后每一步转换成上一步操作 代码示例 1234567891011121314151617181920212223void CalcAllPermutation(char* perm, int from, int to)&#123; if (to &lt;= 1) &#123; return; &#125; if (from == to) &#123; for (int i = 0; i &lt;= to; i++) cout &lt;&lt; perm[i]; cout &lt;&lt; endl; &#125; else &#123; for (int j = from; j &lt;= to; j++) &#123; swap(perm[j], perm[from]); CalcAllPermutation(perm, from + 1, to); swap(perm[j], perm[from]); &#125; &#125;&#125; 字典序排列：利用STL中的next_permutation算法实现 字母组合问题描述： 求出由26个英文字母组成的所有组合 分析过程： 用0和1分别表示对应位字母，组成一张gray表，解析这张表即可得到所有字母的组合 例如abc对应的gray表为:000 001 011 010 110 111 101 100 代码示例： 12345678910111213141516171819typedef vector&lt;string&gt; gray;char a[27] = "abcdefghijklmnopqrstuvwxyz";gray gernalGrayCode(int n)&#123; gray code(pow(2,n)); int len = code.size(); if(n == 1)&#123; code[0] = "0"; code[1] = "1"; return code; &#125; gray g_code = gernalGrayCode(n - 1); for(int i = 0; i &lt; g_code.size(); i++) &#123; code[i] = "0" + g_code[i]; code[len - 1 - i] = "1" + g_code[i]; &#125; return code;&#125; 另一种利用非递归的方式构造格雷码，非常简洁的代码 1234567vector&lt;int&gt; grayCode(int n) &#123; vector&lt;int&gt;res; for(int i=0;i&lt;(1&lt;&lt;n);i++)&#123;//执行2^n次，因为n位格雷码总共有2^n个编码 res.push_back(i^(i&gt;&gt;1));//关键步骤，利用异或运算产生和当前编码有且只有一位不同的格雷码 &#125; return res; &#125; 小结扩展 ① 第一个只出现一次的字符 在一个字符串中找到第一个只出现一次的字符。如输入abaccdeff，则输出b。 ② 对称子字符串的最大长度 输入一个字符串，输出该字符串中对称的子字符串的最大长度。比如输入字符串google，由于该字符串里最长的对称子字符串是goog，因此输出4。提示：可能很多人都写过判断一个字符串是不是对称的函数，这个题目可以看成是该函数的加强版。 ③ 编程判断俩个链表是否相交 给出俩个单向链表的头指针，比如h1，h2，判断这俩个链表是否相交。为了简化问题，我们假设俩个链表均不带环。问题扩展：如果链表可能有环列?如果需要求出俩个链表相交的第一个节点列? ④ 逆序输出链表 输入一个链表的头结点，从尾到头反过来输出每个结点的值。 ⑤ 在O(1)时间内删除单链表结点 给定单链表的一个结点的指针，同时该结点不是尾结点，此外没有指向其它任何结点的指针，请在O(1)时间内删除该结点。 ⑥ 找出链表的第一个公共结点 两个单向链表，找出它们的第一个公共结点。 ⑦ 在字符串中删除特定的字符 输入两个字符串，从第一字符串中删除第二个字符串中所有的字符。例如，输入They are students.和aeiou，则删除之后的第一个字符串变成Thy r stdnts.。 ⑧字符串的匹配 在一篇英文文章中查找指定的人名，人名使用二十六个英文字母（可以是大写或小写）、空格以及两个通配符组成* ?，通配符*表示零个或多个任意字母，通配符?表示一个任意字母。如：J* Smi?? 可以匹配John Smith . ⑨ 字符个数的统计 char *str = &quot;AbcABca&quot; 写出一个函数，查找出每个字符的个数，区分大小写，要求时间复杂度是n（提示用ASCII码） ⑩ 最小子串 给一篇文章，里面是由一个个单词组成，单词中间空格隔开，再给一个字符串指针数组，比如 char *str[]={&quot;hello&quot;,&quot;world&quot;,&quot;good&quot;};求文章中包含这个字符串指针数组的最小子串。注意，只要包含即可，没有顺序要求。提示：文章也可以理解为一个大的字符串数组，单词之前只有空格，没有标点符号。 数组寻找第k小的数问题描述： 输入n个整数，输出其中第k小的 分析过程： 选取S中一个元素作为枢纽元v，将集合S-{v}分割成S1和S2，就像快速排序那样 如果k &lt;= |S1|，那么第k个最小元素必然在S1中。在这种情况下，返回QuickSelect(S1, k)。如果k = 1 + |S1|，那么枢纽元素就是第k个最小元素，即找到，直接返回它。 否则，这第k个最小元素就在S2中，即S2中的第（k - |S1| - 1）个最小元素，我们递归调用并返回QuickSelect(S2, k - |S1| - 1)。代码示例： 此算法的平均运行时间为O(n)。 代码示例： 1234567891011121314151617181920212223242526272829//QuickSelect 将第k小的元素放在 a[k-1] void QuickSelect( int a[], int k, int left, int right )&#123; int i, j; int pivot; if( left + cutoff &lt;= right ) &#123; pivot = median3( a, left, right ); //取三数中值作为枢纽元，可以很大程度上避免最坏情况 i = left; j = right - 1; for( ; ; ) &#123; while( a[ ++i ] &lt; pivot )&#123; &#125; while( a[ --j ] &gt; pivot )&#123; &#125; if( i &lt; j ) swap( &amp;a[ i ], &amp;a[ j ] ); else break; &#125; //重置枢纽元 swap( &amp;a[ i ], &amp;a[ right - 1 ] ); if( k &lt;= i ) QuickSelect( a, k, left, i - 1 ); else if( k &gt; i + 1 ) QuickSelect( a, k, i + 1, right ); &#125; else InsertSort( a + left, right - left + 1 );&#125; 寻找和为定值的多个数问题描述： 输入两个整数n和sum，从数列1，2，3…….n 中随意取几个数，使其和等于sum，要求将其中所有的可能组合列出来。 分析过程： 解法一： 注意到取n，和不取n个区别即可，考虑是否取第n个数的策略，可以转化为一个只和前n-1个数相关的问题。 如果取第n个数，那么问题就转化为“取前n-1个数使得它们的和为sum-n”，对应的代码语句就是sumOfkNumber(sum - n, n - 1)； 如果不取第n个数，那么问题就转化为“取前n-1个数使得他们的和为sum”，对应的代码语句为sumOfkNumber(sum, n - 1)。 参考代码： 1234567891011121314151617181920void SumOfkNumber(int sum, int n)&#123; // 递归出口 if (n &lt;= 0 || sum &lt;= 0) return; // 输出找到的结果 if (sum == n) &#123; // 反转list list1.reverse(); for (list&lt;int&gt;::iterator iter = list1.begin(); iter != list1.end(); iter++) cout &lt;&lt; *iter &lt;&lt; " + "; cout &lt;&lt; n &lt;&lt; endl; list1.reverse()//此处还需反转回来 &#125; list1.push_front(n); //典型的01背包问题 SumOfkNumber(sum - n, n - 1); //“放”n，前n-1个数“填满”sum-n list1.pop_front(); SumOfkNumber(sum, n - 1); //不“放”n，n-1个数“填满”sum&#125; 解法二： 这个问题属于子集和问题（也是背包问题）。本程序采用回溯法+剪枝，其中X数组是解向量，t=∑(1,..,k-1)Wi*Xi, r=∑(k,..,n)Wi，且 若t+Wk+W(k+1)&lt;=M,则Xk=true，递归左儿子(X1,X2,..,X(k-1),1)；否则剪枝； 若t+r-Wk&gt;=M &amp;&amp; t+W(k+1)&lt;=M,则置Xk=0，递归右儿子(X1,X2,..,X(k-1),0)；否则剪枝； 本题中W数组就是(1,2,..,n),所以直接用k代替WK值 参考代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//输入t， r， 尝试Wkvoid SumOfkNumber(int t, int k, int r, int&amp; M, bool&amp; flag, bool* X)&#123; X[k] = true; // 选第k个数 if (t + k == M) // 若找到一个和为M，则设置解向量的标志位，输出解 &#123; flag = true; for (int i = 1; i &lt;= k; ++i) &#123; if (X[i] == 1) &#123; printf("%d ", i); &#125; &#125; printf("\n"); &#125; else &#123; // 若第k+1个数满足条件，则递归左子树 if (t + k + (k + 1) &lt;= M) &#123; SumOfkNumber(t + k, k + 1, r - k, M, flag, X); &#125; // 若不选第k个数，选第k+1个数满足条件，则递归右子树 if ((t + r - k &gt;= M) &amp;&amp; (t + (k + 1) &lt;= M)) &#123; X[k] = false; SumOfkNumber(t, k + 1, r - k, M, flag, X); &#125; &#125;&#125;void search(int&amp; N, int&amp; M)&#123; // 初始化解空间 bool* X = (bool*)malloc(sizeof(bool)* (N + 1)); memset(X, false, sizeof(bool)* (N + 1)); int sum = (N + 1) * N * 0.5f; if (1 &gt; M || sum &lt; M) // 预先排除无解情况 &#123; printf("not found\n"); return; &#125; bool f = false; SumOfkNumber(0, 1, sum, M, f, X); if (!f) &#123; printf("not found\n"); &#125; free(X);&#125; 背包问题扩展 背包问题是最基础的背包问题，其具体描述为：有N件物品和一个容量为V的背包。放入第i件物品耗费的费用是Ci，得到的价值是Wi。求解将哪些物品装入背包可使价值总和最大。 简单分析下：这是最基础的背包问题，特点是每种物品仅有一件，可以选择放或不放。用子问题定义状态：即F[i, v]表示前i件物品恰放入一个容量为v的背包可以获得的最大价值。则其状态转移方程便是： F[i, v] = max{F[i-1, v], F[i-1, v-Ci ] + Wi} 根据前面的分析，我们不难理解这个方程的意义：“将前i件物品放入容量为v的背包中”这个子问题，若只考虑第i件物品的策略（放或不放），那么就可以转化为一个只和前 i-1 件物品相关的问题。即： 如果不放第i件物品，那么问题就转化为“前i-1件物品放入容量为v的背包中”，价值为 F[i-1, v ]； 如果放第i件物品，那么问题就转化为“前i-1件物品放入剩下的容量为v-Ci的背包中”，此时能获得的最大价值就是F[i-1, v-Ci]再加上通过放入第i件物品获得的价值Wi。伪代码如下： 1234F[0,0...V] ← 0for i ← 1 to N for v ← Ci to V F[i, v] ← max&#123;F[i-1, v], F[i-1, v-Ci] + Wi &#125; 这段代码的时间和空间复杂度均为 O(VN)，其中时间复杂度应该已经不能再优化了，但空间复杂度却可以优化到O(V)。感兴趣的读者可以继续思考或者参考网上一个不错的文档《背包问题九讲》。]]></content>
      <categories>
        <category>The-Art-Of-Programming</category>
      </categories>
      <tags>
        <tag>The-Art-Of-Programming</tag>
      </tags>
  </entry>
</search>
